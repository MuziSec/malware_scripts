from binascii import hexlify, unhexlify
import pefile
import regex as re
import argparse
import logging
import traceback
import os
import sys
import json
import hashlib
import yara
import subprocess
import shutil
import base64
import gzip
from pathlib import Path
from binascii import hexlify, unhexlify
import extract_config

repo_root = Path(os.path.realpath(__file__)).parent.parent.absolute()
lib = os.path.join(repo_root, 'lib')
sys.path.append(lib)
from utils import *

repo = Path(os.path.realpath(__file__)).parent
lib2 = os.path.join(repo, 'Unpackers-and-Config-Extractors/forest')
sys.path.append(lib2)
from unpacker import *

def configure_logger(log_level):
    log_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'bumblebee_config_extractor.log')
    log_levels = {0: logging.ERROR, 1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}
    log_level = min(max(log_level, 0), 3) #clamp to 0-3 inclusive
    logging.basicConfig(level=log_levels[log_level], 
                        format='%(asctime)s - %(name)s - %(levelname)-8s %(message)s',
                        handlers=[
                            logging.FileHandler(log_file, 'a'),
                            logging.StreamHandler()
                        ])

class Processor:
    
    def __init__(self, input_file):
        self.logger = logging.getLogger('BumbleBee Config Extractor Logger')
        self.input_file = input_file
        self.outpath = ""
        with open(self.input_file, 'rb') as fp:
            self.data = fp.read()
        self.stageone_regex = re.compile(r'\"(?<b64gz>.4sIAAAA[A-Za-z0-9+/=]+)\"') 
        self.stagetwo_regex = re.compile(r'\[Byte\[\]\]\((?<pe_file>0x[A-Fa-f0-9]{2}.*)\)') 
        self.stagetwo_regex2 = re.compile('FromBase64String\((\'|\")(?<b64_string>[A-Za-z0-9+/=].*)(\'|\")') 
        self.rules = yara.compile('yara/bumblebee.yar')

    def parse_stage_one(self, file): 
        """
        Parse Stage One PowerShell Loader
        """
        with open(file, 'rb') as fp:
            data = fp.read().decode('utf-16')
        try:
            compressed_data = self.stageone_regex.finditer(data)
            self.logger.debug(f'Base64 GZ data found in stage one.')
        except Exception as e:
            self.logger.critical(f'Could not extract Base64 GZ data from stage one powershell.')
            return
        pt = []
        for idx, match in enumerate(compressed_data):
            pt.append(('H' + match.group('b64gz')[1:]))
        with open(os.path.join(self.outpath, 'stage2.ps1'), 'w') as fp:
            for x in pt:
                fp.write(gzip.decompress(base64.b64decode(x)).decode('ascii'))
        self.logger.critical(f'Second stage PowerShell loader written to: {os.path.join(self.outpath, "stage2.ps1")}')
        return os.path.join(self.outpath, 'stage2.ps1')

    def parse_stage_two(self, file):
        """
        Parse Stage Two PowerShell Loader
        """
        with open(os.path.join(self.outpath, 'stage2.ps1'), 'r') as fp:
            stage2_data = fp.read()
        try:
            extracted_dll = self.stagetwo_regex.search(stage2_data)
            self.logger.debug(f'Hexlified PE file found in stage two.')
        except Exception as e:
            self.logger.debug(f'Hexlified PE not found in stage two. Checking for Base64 next.')
        if extracted_dll:
            extracted_dll = str.encode('4d' + extracted_dll.group('pe_file').replace('0x', '').replace(',', '')[2:])
        else:
            extracted_dll2 = bytearray(b'\x4d')
            try:
                extracted_b64strings = self.stagetwo_regex2.finditer(stage2_data)
                self.logger.debug(f'Base64 PE file found in stage two.')
            except Exception as e:
                self.logger.critical(f'Could not identify PE file in stage two powershell. Returning')
                return
            for index, match in enumerate(extracted_b64strings):
                extracted_dll2 += bytearray(base64.b64decode(match.group('b64_string')))
    
        with open(os.path.join(self.outpath, 'packed_dll.dll'), 'wb') as fp:
            if extracted_dll:
                extracted_dll = unhexlify(extracted_dll)
                fp.write(extracted_dll)
            elif extracted_dll2:
                fp.write(extracted_dll2)
                extracted_dll = extracted_dll2
        self.logger.critical(f'Embedded DLL extracted from Stage Two PowerShell and written to {os.path.join(self.outpath, "packed_dll.dll")}')
        return extracted_dll

    def write_results(self, extracted_dll):
        """
        Write results to disk
        """
        for result in extracted_dll:
            fname = hashlib.md5(result['data']).hexdigest() + '.dll'
            with open(os.path.join(self.outpath, fname), 'wb') as fp:
                fp.write(result['data'])

    def extract_bumblebee_config(self):
        """
        Scan directory for unpacked Bumblebee and extract config
        """
        bumblebee = None
        matches = scan_dir(self.outpath, self.rules)
        for key, value in matches.items():
            if 'packed_dll' not in key and value == 'Classification_Bumblebee':
                bumblebee = key
                self.logger.critical(f'Bumblebee binary identified: {key}') 
              
        # Extract Config
        if bumblebee:
            extractor = extract_config.Extractor(bumblebee)
            extractor.extract_config() 
        else:
            self.logger.critical(f'Could not identify BumbleBee in extracted output.')

    def process_file(self):
        """
        Handle file, pass off to extractors.
        """
        # Make new directory to work from
        md5_hash = hashlib.md5(open(self.input_file,'rb').read()).hexdigest()      
        os.makedirs(md5_hash, exist_ok=True)  
        self.outpath = os.path.join(os.getcwd(), md5_hash)

        # Scan file to see how to handle it
        try:
            matches = self.rules.match(self.input_file)
        except Exception as e:
            self.logger.critical(f'Provided file did not match Bumblebee rules. Are you sure this is Bumblebee?')
            return

        # Handle File based on Yara rule
        if matches[0].rule == 'BumbleBee_VHD_drops_LNK':
            # Copy file to output directory
            shutil.copy(self.input_file, self.outpath)         
            # File is VHD and needs contents extracted
            unzip_cmd = ['7z', 'x', self.input_file, '-o'+self.outpath, '-y']
            s = subprocess.check_output(unzip_cmd) 
            self.logger.debug(s)

            # Find PowerShell Loader Stage 1
            test = scan_dir(self.outpath, self.rules)
            for key, value in test.items():
                if value == 'Bumblebee_PSLoader_Stage_One':
                    stage_one = key
                    self.logger.critical(f'Stage one PowerShell Loader identified: {stage_one}') 

            # Parse PowerShell Stage 1
            stage2_path = self.parse_stage_one(stage_one)

            # Extract DLL from Stage 2 PowerShell Loader
            if stage2_path:
                extracted_dll = self.parse_stage_two(stage2_path)           
            else:
                self.logger.critical('Could not extract stage two powershell.') 
                return

            # Extract embedded DLLs from extracted DLL
            if extracted_dll:
                results = carve(extracted_dll) 
            else:
                self.logger.critical('Could not extract embedded DLL from stage two powershell.')
                return   

            # Write results 
            self.write_results(results)            
            
            # Extract Bumblebee Config
            self.extract_bumblebee_config() 
 
        elif matches[0].rule == 'Bumblebee_PSLoader_Stage_One':
            
            # Copy file to output directory
            shutil.copy(self.input_file, self.outpath)         
            
            stage_one = self.input_file         

            # Parse PowerShell Stage 1
            stage2_path = self.parse_stage_one(stage_one)

            # Extract DLL from Stage 2 PowerShell Loader
            if stage2_path:
                extracted_dll = self.parse_stage_two(stage2_path)
            else:
                self.logger.critical('Could not extract stage two powershell.')           
                return

            # Extract embedded DLLs from extracted DLL
            if extracted_dll:
                results = carve(extracted_dll) 
            else:
                self.logger.critical('Could not extract embedded DLL from stage two powershell.')
                return

            # Write results
            self.write_results(results)

            # Extract Bumblebee Config
            self.extract_bumblebee_config()        
 
        # Handle new packed DLL     
        elif len(matches) > 1 and matches[1].rule == 'Bumblebee_Hookloader':
            self.logger.critical(f'Identified Bumblebee Hookloader variant: {self.input_file}')            
            
            # Copy file to output directory
            shutil.copy(self.input_file, self.outpath)         
            
            # Carve embedded PEs
            with open(self.input_file, 'rb') as fp:
                in_file = fp.read()
           
            try:
                results = carve(in_file)
            except Exception as e:
                self.logger.critical('Could not extract DLLs from Hookloader.')
            
            # Write results
            self.write_results(results)

            # Extract Bumblebee Config
            self.extract_bumblebee_config() 


        # Handle Forest packed Bumblebee
        elif matches[0].rule == 'Forest_Crypter':
            self.logger.critical(f'Identified Forest Crypter')
            
            # Copy file to output directory
            shutil.copy(self.input_file, self.outpath)         
            
            # Unpack Bumblebee from Forest Crypter
            unpacker = ForestUnpacker(path=self.input_file, config_path=os.path.join(lib2, 'config.yml'), dump_dir=self.outpath)
            unpacker.run()
            unpacker.extract_payload()
            
            # Extract Bumblebee Config
            self.extract_bumblebee_config()

        # Handle unpacked Bumblebee
        elif matches[0].rule == 'Classification_Bumblebee':
            self.logger.critical(f'Identified unpacked Bumblebee')
  
            # Copy file to output directory
            shutil.copy(self.input_file, self.outpath)         
            
            # Extract Bumblebee Config
            self.extract_bumblebee_config()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='BumbleBee Config Extractor')
    parser.add_argument('-v', '--verbose', action='count', default=0, 
        help='Increase verbosity. Can specify multiple times for more verbose output')
    parser.add_argument('files', nargs='+') 
    args = parser.parse_args()
    configure_logger(args.verbose)
    for file in args.files:
        processor = Processor(file)
        try:
            processor.process_file()
        except Exception as e:
            print(f'Exception processing {file}:')
            print(traceback.format_exc())
    
