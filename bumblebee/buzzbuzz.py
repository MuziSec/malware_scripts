from binascii import hexlify, unhexlify
import pefile
import regex as re
import argparse
import logging
import traceback
import os
import sys
import json
import hashlib
import yara
import subprocess
import shutil
import base64
import gzip
from pathlib import Path
from binascii import hexlify, unhexlify
import extract_config

repo_root = Path(os.path.realpath(__file__)).parent.parent.absolute()
lib = os.path.join(repo_root, 'lib')
sys.path.append(lib)
from utils import *

def configure_logger(log_level):
    log_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'bumblebee_config_extractor.log')
    log_levels = {0: logging.ERROR, 1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}
    log_level = min(max(log_level, 0), 3) #clamp to 0-3 inclusive
    logging.basicConfig(level=log_levels[log_level], 
                        format='%(asctime)s - %(name)s - %(levelname)-8s %(message)s',
                        handlers=[
                            logging.FileHandler(log_file, 'a'),
                            logging.StreamHandler()
                        ])

class Processor:
    
    def __init__(self, input_file):
        self.logger = logging.getLogger('BumbleBee Config Extractor Logger')
        self.input_file = input_file
        self.outpath = ""
        with open(self.input_file, 'rb') as fp:
            self.data = fp.read()
        self.stageone_regex = re.compile(r'\".4sIAAAA[A-Za-z0-9+/=].*\"') 
        self.stagetwo_regex = re.compile(r'\[Byte\[\]\]\(0x[A-Fa-f0-9]{2}.*\)') 
        self.stagetwo_regex2 = re.compile('FromBase64String\((\'|\")(?<b64_string>[A-Za-z0-9+/=].*)(\'|\")') 

    def process_file(self):
        """
        Handle file, pass off to extractors.
        """
        # Make new directory to work from
        md5_hash = hashlib.md5(open(self.input_file,'rb').read()).hexdigest()      
        os.makedirs(md5_hash, exist_ok=True)  
        self.outpath = os.path.join(os.getcwd(), md5_hash)

        # Scan file to see how to handle it
        rules = yara.compile('yara/bumblebee.yar') 
        matches = rules.match(self.input_file)

        # Handle File based on Yara rule
        if matches[0].rule == 'BumbleBee_VHD_drops_LNK':
            # Copy file to output directory
            shutil.copy(self.input_file, self.outpath)         
            # File is VHD and needs contents extracted
            unzip_cmd = ['7z', 'x', self.input_file, '-o'+self.outpath, '-y']
            s = subprocess.check_output(unzip_cmd) 
            self.logger.debug(s)

            # Find PowerShell Loader Stage 1
            test = scan_dir(self.outpath, rules)
            for key, value in test.items():
                if value == 'Bumblebee_PSLoader_Stage_One':
                    stage_one = key
            self.logger.critical(f'Stage one PowerShell Loader identified: {stage_one}') 

            # Parse PowerShell Stage 1
            with open(stage_one, 'rb') as fp:
                data = fp.read().decode('utf-16')
            compressed_data = self.stageone_regex.findall(data)
            for idx in range(len(compressed_data)):
                compressed_data[idx] = 'H' + compressed_data[idx][2:-1]

            # Write second stage PowerShell loader
            with open(os.path.join(self.outpath,'stage2.ps1'), 'w') as fp:
                for x in compressed_data:
                    fp.write(gzip.decompress(base64.b64decode(x)).decode('ascii'))
            self.logger.critical(f'Second stage PowerShell loader written to: {os.path.join(self.outpath, "stage2.ps1")}')

            # Extract DLL from Stage 2 PowerShell Loader
            with open(os.path.join(self.outpath, 'stage2.ps1'), 'r') as fp:
                stage2_data = fp.read()
            extracted_dll = self.stagetwo_regex.search(stage2_data)
            if extracted_dll:
                extracted_dll = str.encode('4d' + extracted_dll[0][9:-1].replace('0x', '').replace(',', '')[2:])
            else:
                extracted_dll2 = bytearray(b'\x4d')
                extracted_b64strings = self.stagetwo_regex2.finditer(stage2_data)
                for index, match in enumerate(extracted_b64strings):
                    extracted_dll2 += bytearray(base64.b64decode(match.group('b64_string')))

            # Write extracted DLL
            with open(os.path.join(self.outpath, 'packed_dll.dll'), 'wb') as fp:
                if extracted_dll:
                    fp.write(unhexlify(extracted_dll))
                elif extracted_dll2:
                    fp.write(extracted_dll2)
            
            # Extract embedded DLLs from extracted DLL
            if extracted_dll:
                results = carve(unhexlify(extracted_dll)) 
            elif extracted_dll2:
                results = carve(extracted_dll2)

            # Write embedded DLLs from extracted DLL
            for result in results:
                fname = hashlib.md5(result['data']).hexdigest() + '.dll'
                with open(os.path.join(self.outpath, fname), 'wb') as fp:
                    fp.write(result['data'])

            # Scan DLLs for BumbleBee
            matches = scan_dir(self.outpath, rules)
            for key, value in matches.items():
                if 'packed_dll' not in key and value == 'Classification_Bumblebee':
                    bumblebee = key
                    self.logger.critical(f'Bumblebee binary identified: {key}') 
   
            # Extract Config
            extractor = extract_config.Extractor(bumblebee)
            extractor.extract_config()  
        elif matches[0].rule == 'Bumblebee_PSLoader_Stage_One':
            stage_one = self.input_file         

            # Parse PowerShell Stage 1
            with open(stage_one, 'rb') as fp:
                data = fp.read().decode('utf-16')
            compressed_data = self.stageone_regex.findall(data)
            for idx in range(len(compressed_data)):
                compressed_data[idx] = 'H' + compressed_data[idx][2:-1]

            # Write second stage PowerShell loader
            with open(os.path.join(self.outpath,'stage2.ps1'), 'w') as fp:
                for x in compressed_data:
                    fp.write(gzip.decompress(base64.b64decode(x)).decode('ascii'))
            self.logger.critical(f'Second stage PowerShell loader written to: {os.path.join(self.outpath, "stage2.ps1")}')

            # Extract DLL from Stage 2 PowerShell Loader
            with open(os.path.join(self.outpath, 'stage2.ps1'), 'r') as fp:
                stage2_data = fp.read()
            extracted_dll = self.stagetwo_regex.search(stage2_data)
            if extracted_dll:
                extracted_dll = str.encode('4d' + extracted_dll[0][9:-1].replace('0x', '').replace(',', '')[2:])
            else:
                extracted_dll2 = bytearray(b'\x4d')
                extracted_b64strings = self.stagetwo_regex2.finditer(stage2_data)
                for index, match in enumerate(extracted_b64strings):
                    extracted_dll2 += bytearray(base64.b64decode(match.group('b64_string')))

            # Write extracted DLL
            with open(os.path.join(self.outpath, 'packed_dll.dll'), 'wb') as fp:
                if extracted_dll:
                    fp.write(unhexlify(extracted_dll))
                elif extracted_dll2:
                    fp.write(extracted_dll2)
            
            # Extract embedded DLLs from extracted DLL
            if extracted_dll:
                results = carve(unhexlify(extracted_dll)) 
            elif extracted_dll2:
                results = carve(extracted_dll2)

            # Write embedded DLLs from extracted DLL
            for result in results:
                fname = hashlib.md5(result['data']).hexdigest() + '.dll'
                with open(os.path.join(self.outpath, fname), 'wb') as fp:
                    fp.write(result['data'])

            # Scan DLLs for BumbleBee
            matches = scan_dir(self.outpath, rules)
            for key, value in matches.items():
                if 'packed_dll' not in key and value == 'Classification_Bumblebee':
                    bumblebee = key
                    self.logger.critical(f'Bumblebee binary identified: {key}') 
   
            # Extract Config
            extractor = extract_config.Extractor(bumblebee)
            extractor.extract_config()  
        
        # Handle new packed DLL     
        #elif matches[0].rule == 'Bumblebee_PSLoader_Stage_One':
        
        # Handle Forest packed Bumblebee
        #elif matches[0].rule == 'Bumblebee_PSLoader_Stage_One':
            

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='BumbleBee Config Extractor')
    parser.add_argument('-v', '--verbose', action='count', default=0, 
        help='Increase verbosity. Can specify multiple times for more verbose output')
    parser.add_argument('files', nargs='+') 
    args = parser.parse_args()
    configure_logger(args.verbose)
    for file in args.files:
        processor = Processor(file)
        try:
            processor.process_file()
        except Exception as e:
            print(f'Exception processing {file}:')
            print(traceback.format_exc())
    
