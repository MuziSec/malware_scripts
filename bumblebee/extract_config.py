from binascii import hexlify, unhexlify
import pefile
import regex as re
import argparse
import logging
import traceback
import os
from arc4 import ARC4
import json

def configure_logger(log_level):
    log_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'bumblebee_config_extractor.log')
    log_levels = {0: logging.ERROR, 1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}
    log_level = min(max(log_level, 0), 3) #clamp to 0-3 inclusive
    logging.basicConfig(level=log_levels[log_level], 
                        format='%(asctime)s - %(name)s - %(levelname)-8s %(message)s',
                        handlers=[
                            logging.FileHandler(log_file, 'a'),
                            logging.StreamHandler()
                        ])

class Extractor:
    
    def __init__(self, input_file, output_file=None):
        self.logger = logging.getLogger('BumbleBee Config Extractor Logger')
        self.input_file = input_file
        self.output_file = output_file
        self.key_regex = re.compile(rb'(\x48\x8D.(?P<key>....)\x80\x3D....\x00)', re.DOTALL)
        self.regex = re.compile(rb'(?<campaign_id_ins>\x48\x8D.(?P<campaign_id>....))(?P<botnet_id_ins>\x48\x8D.(?P<botnet_id>....))(?P<c2s_ins>\x48\x8D.(?P<c2s>....))', re.DOTALL)
        self.output_strings = []
        with open(self.input_file, 'rb') as fp:
            self.data = fp.read()
        self.pe = pefile.PE(self.input_file, fast_load=False)

    def rc4_decrypt(self, key, ciphertext):
        """
        RC4 Decrypt Ciphertext
        """
        arc4 = ARC4(key)
        return arc4.decrypt(ciphertext)

    def extract_key_data(self, key_match):
        """
        Given key match, convert rva to file offset and return key data at that offset.
        """
        try:
            # Get relative rva. The LEA is using a relative address. This address is relative to the address of the next ins.
            relative_rva = self.pe.get_rva_from_offset(key_match.start() + int(len(key_match.group())/2))      
            # Now that we have the relative rva, we need to get the file offset
            key_offset = self.pe.get_offset_from_rva(relative_rva + int.from_bytes(key_match.group('key'), byteorder='little'))
            # Read arbitrary number of byes from key offset and split on null bytes to extract key
            key = self.data[key_offset:key_offset+0x40].split(b'\x00')[0]
        except Exception as e:
            self.logger.debug(f'There was an exception extracting the key: {e}')
            self.logger.debug(traceback.format_exc())
            raise
        return key

    def extract_config_data(self, config_match):
        """
        Given config match, convert rva to file offset and return data at that offset.
        The LEA ins are using relative addressing. Referenced data is relative to the address of the NEXT ins.
        This is inefficient but I'm bad at Python, okay?
        """
        try:
            # Get campaign id ciphertext
            campaign_id_rva = self.pe.get_rva_from_offset(config_match.start() + int(len(config_match.group('campaign_id_ins'))))
            campaign_id_offset = self.pe.get_offset_from_rva(campaign_id_rva + int.from_bytes(config_match.group('campaign_id'), byteorder='little'))
            campaign_id_ct = self.data[campaign_id_offset:campaign_id_offset+0x10]
        except Exception as e:
            self.logger.debug(f'There was an exception extracting the campaign id: {e}')
            self.logger.debug(traceback.format_exc())
            raise

        try:
            # Get botnet id ciphertext
            botnet_id_rva = self.pe.get_rva_from_offset(config_match.start() + int(len(config_match.group('campaign_id_ins'))) + int(len(config_match.group('botnet_id_ins'))))
            botnet_id_offset = self.pe.get_offset_from_rva(botnet_id_rva + int.from_bytes(config_match.group('botnet_id'), byteorder='little')) 
            botnet_id_ct = self.data[botnet_id_offset:botnet_id_offset+0x10]
        except Exception as e:
            self.logger.debug(f'There was an exception extracting the botnet id: {e}')
            self.logger.debug(traceback.format_exc())
            raise        

        # Get C2 ciphertext
        try:
            c2s_rva = self.pe.get_rva_from_offset(config_match.start() + int(len(config_match.group('campaign_id_ins'))) + int(len(config_match.group('botnet_id_ins'))) + int(len(config_match.group('c2s_ins'))))
            c2s_offset = self.pe.get_offset_from_rva(c2s_rva + int.from_bytes(config_match.group('c2s'), byteorder='little'))
            c2s_ct = self.data[c2s_offset:c2s_offset+0x400]
        except Exception as e:
            self.logger.debug(f'There was an exception extracting the C2s: {e}')
            self.logger.debug(traceback.format_exc())
            raise

        return campaign_id_ct, botnet_id_ct, c2s_ct

    def extract_config(self):
        """
        Extract key and config and decrypt
        """
        self.logger.critical(f'Extracting config from: {self.input_file}')        
        # Extract Key
        key_match = list(self.key_regex.finditer(self.data))
        config_dict = dict()
        config_dict['File'] = self.input_file
        if len(key_match) > 1:
            for index, match in enumerate(key_match):
                key = self.extract_key_data(match)
                if index == 0:
                    config_dict['BotnetID'] = key.decode('utf-8')
                elif index == 1:
                    config_dict['CampaignID'] = key.decode('utf-8')
                elif index == 2:
                    config_dict['Data'] = key.decode('utf-8')
                elif index == 3:
                    config_dict['C2s'] = key.decode('utf-8').split(',')
                    print(json.dumps(config_dict, indent=4, sort_keys=False))
                    return
        elif len(key_match) == 1:
            key = self.extract_key_data(key_match[0])
            self.logger.critical(f'RC4 Key Hexlified: {hexlify(key)}')
            self.logger.critical(f'RC4 Key: {key}')


        # Extract config ciphertext
        try:
            config_match = self.regex.search(self.data) 
            self.logger.debug(f'Config match: {hexlify(config_match.group())}')
            campaign_id, botnet_id, c2s = self.extract_config_data(config_match)     
        except Exception as e:
            self.logger.critical(f'Could not identify config')
            return    

        # RC4 Decrypt
        try: 
            campaign_id_pt = self.rc4_decrypt(key, campaign_id).split(b'\x00')[0].decode('utf-8')
            botnet_id_pt = self.rc4_decrypt(key, botnet_id).split(b'\x00')[0].decode('utf-8')
            c2s_pt = list(self.rc4_decrypt(key, c2s).split(b'\x00')[0].decode('utf-8').split(','))
        except Exception as e:
            self.logger.critical(f'Could not RC4 decrypt: {e}')

        # Print Config
        config_dict = {'File': self.input_file, 'BotnetID': botnet_id_pt, 'Data': campaign_id_pt, 'C2s': []}
        for c2 in c2s_pt:
            config_dict['C2s'].append(c2)
        print(json.dumps(config_dict, indent=4, sort_keys=False))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='BumbleBee Config Extractor')
    parser.add_argument('-v', '--verbose', action='count', default=0, 
        help='Increase verbosity. Can specify multiple times for more verbose output')
    parser.add_argument('files', nargs='+') 
    args = parser.parse_args()
    configure_logger(args.verbose)
    for file in args.files:
        extractor = Extractor(file)
        try:
            extractor.extract_config()
        except Exception as e:
            print(f'Exception processing {file}:')
            print(traceback.format_exc())
    
