import os
import pefile
from time import time, sleep
from hashlib import md5
from binascii import hexlify
import yara
import regex as re

"""
Most of this code from JHumble https://raw.githubusercontent.com/jhumble/Unpackers-and-Config-Extractors/master/lib/utils.py
"""

def get_compile_time(pe):
    ts = int(pe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split()[0], 16)
    utc_time = datetime.datetime.utcfromtimestamp(ts)
    t_delta = (datetime.datetime.today() - utc_time).days
    return utc_time.strftime(f"%Y-%m-%dT%H:%M:%S")

def rol(dword, i):
    return ((dword << i) & 0xffffffff) | (dword >> (32-i) ) 

def ror(dword, i):
    return rol(dword, 32-i)

def xor(plaintext, key):
    rtn = bytearray(len(plaintext))
    for i in range(len(plaintext)):
        rtn[i] = plaintext[i] ^ key[i%len(key)]
    return rtn

def carve(buf, match_at_start=False):
    found = []
    for i in [match.start() for match in re.finditer(b'MZ', buf)]:
        if i == 0 and not match_at_start: # Ignore matches at offset 0 (regular PE files)
            continue
        try:
            pe = pefile.PE(data=buf[i:])
        except:
            continue
        #print(f'Found PE file at offset 0x{i:X}')
        found.append({'offset': i, 'data': pe.trim(), 'ext': get_ext(pe) })
    return found


def get_ext(pe):
    # https://github.com/MalwareLu/tools/blob/master/pe-carv.py
    'returns ext of the file type using pefile'
    if pe.is_dll() == True:
        return 'dll'
    if pe.is_driver() == True:
        return 'sys'
    if pe.is_exe() == True:
        return 'exe'
    else:
        return 'bin'

def iter_resources(pe):
    for rsrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:
        for entry in rsrc.directory.entries:
            if rsrc.name:
                name = f'{rsrc.name}/{entry.name}'
            else:
                name = entry.name
            offset = entry.directory.entries[0].data.struct.OffsetToData
            size = entry.directory.entries[0].data.struct.Size
            #print(f'{size:08X}')
            if entry.directory.entries[0].name:
                _id = entry.directory.entries[0].name
            else:
                _id = '0x{:X}'.format(entry.directory.entries[0].id)
            #print(f'{offset:08X} {size:08X}')
            data = bytearray(pe.get_memory_mapped_image()[offset:offset+size])
            #print(f'Found resource {name}/{_id}, length: {len(data):08X}')
            yield name, _id, data

def scan_dir(target_dir, rules):
    match_list = dict()
    for file in os.listdir(target_dir):
        path = os.path.join(target_dir, file)
        try:
            matches = rules.match(path)
            if len(matches) > 0:
                match_list[path] = matches[0].rule
        except Exception as e:
            pass
    return match_list
