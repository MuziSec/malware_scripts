from binascii import hexlify, unhexlify
import pefile
import regex as re
import argparse
import logging
import traceback
import os
import subprocess

def configure_logger(log_level):
    log_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), '841_unpack.log')
    log_levels = {0: logging.ERROR, 1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}
    log_level = min(max(log_level, 0), 3) #clamp to 0-3 inclusive
    logging.basicConfig(level=log_levels[log_level], 
                        format='%(asctime)s - %(name)s - %(levelname)-8s %(message)s',
                        handlers=[
                            logging.FileHandler(log_file, 'a'),
                            logging.StreamHandler()
                        ])

class Unpacker:
    
    def __init__(self, input_file, output_file=None):
        self.logger = logging.getLogger('Eight for One Crypter Unpacker')
        self.input_file = input_file
        self.output_file = output_file
        self.xor_key = 0x0
        self.comparison_operator = 0x0
        self.solve = 0
        self.output = bytearray()
        with open(self.input_file, 'rb') as fp:
            self.data = fp.read()

    def unpack(self):
        """
        Extract ciphertext (giant string used for calculating and writing out plaintext aka unpacked exe) and keys and perform operations to unpack exe
        """
        # Extract CT
        r = re.compile(b'[0-9.,+\-*/;:()]{512,}')
        ct = bytearray(r.search(self.data).group())

        # Extract comparison operator for algorithm
        co_r = re.compile(b'\x83\xc4\x04\x0f\xb6(\x45|\x4D|\x55|\x5D|\x6D|\x75|\x7D).\x83.(?P<cmp>.)', re.DOTALL)
        matches = list(co_r.finditer(self.data))
        self.comparison_operator = bytearray(co_r.search(self.data).group('cmp'))
 
        # Init vars for unpacking algorithm
        counter = 0
        var1 = 0x0
        var2 = 0x01

        # Loop through ct
        for i in range(0, len(ct)):
            if counter < 8:
                self.logger.debug(f'Val is {ct[i]}')
                self.logger.debug(f'XOR Key is {self.xor_key}')
                var1, var2 = self.unpack_algo(ct[i], var1, var2)
                counter += 1
            if counter == 8:
                if self.solve == 0:
                    self.xor_key = 0x4D ^ var1
                    print(f'Xor key is {self.xor_key}')
                    self.solve = 1
                self.output.append(var1 ^ self.xor_key)
                counter = 0
                var1 = 0x0
                var2 = 0x1
                if self.xor_key == 0xFF:
                    self.xor_key = 0x0
                else:
                    self.xor_key += 0x1

    def unpack_algo(self, ct, var1, var2):
        """
        This algorithm is likely implemented in a much more efficient manner. I have essentially mirrored the assembly here. I will update when I take another look.
        """
        try:
            if ct >= self.comparison_operator[0]:
                self.logger.debug(f'{ct} is >= {self.comparison_operator}')
                var1 = var1 | var2
                var2 = var2 << 0x1
            elif ct < self.comparison_operator[0]:
                self.logger.debug(f'{ct} is < {self.comparison_operator}')
                var2 = var2 << 0x1
            self.logger.debug(f'Var1 is {var1} and Var2 is {var2}')
        except Exception as e:
            self.logger.critical(traceback.format_exc())
            self.logger.critical(f'There was an error with the input to the unpack algorithm.')
            raise   
        return var1, var2        

    def write_output(self):
        """
        Write output to a given file
        """
        try:
            with open(self.output_file, 'wb') as fp:
                fp.write(self.output)
        except Exception as e:
            self.logger.critical(traceback.format_exc())
            

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Eight for One Crypter Unpacker')
    parser.add_argument('-f', '--file', action='store', dest='file',
                        required=True, help='Path of file to unpack')
    parser.add_argument('-o', '--outfile', action='store', dest='outfile',
                        required=False, help='Path to write unpacked file')
    parser.add_argument('-v', '--verbose', action='count', default=0, 
        help='Increase verbosity. Can specify multiple times for more verbose output')
    args = parser.parse_args()
    configure_logger(args.verbose)
    unpacker = Unpacker(args.file, args.outfile)
    try:
        unpacker.unpack()
        if args.outfile:
            unpacker.write_output()
    except Exception as e:
        print(f'Exception processing {args.file}:')
        print(traceback.format_exc())
    
