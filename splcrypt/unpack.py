import speakeasy
import logging
import pefile
import argparse
import re
import struct

def get_logger():
    """
    Get the default logger for speakeasy
    """
    logger = logging.getLogger('emu_dll')
    if not logger.handlers:
        sh = logging.StreamHandler()
        logger.addHandler(sh)
        logger.setLevel(logging.DEBUG)

    return logger

class SPLCryptUnpacker(speakeasy.Speakeasy):
    def __init__(self, input_path, output_path):
        super(SPLCryptUnpacker, self).__init__(debug = False, logger=get_logger())
        self.input_path = input_path
        self.output_path = output_path
        self.dump_addr = []

    def dump(self):
        
        for addr in self.dump_addr:
            #image = self.get_address_map(addr['Base'])
            self.pe_data = self.mem_read(addr['Base'],addr['Length']) 
            print("[*] Searching for PE in allocated memory regions")
            for i in self.carve(self.pe_data):
                print("[*] PE Found in allocated memory")
                path = self.output_path + "." + i['ext']
                print(f'[*] Writing PE: {path}')
                with open(path, 'wb') as fp:
                    fp.write(i['data'])

    def carve(self,buf):
        found = []
        for i in [match.start() for match in re.finditer(b'MZ', buf)]:
            if i == 0: # Ignore matches at offset 0 (regular PE files)
                continue
            try:
                pe = pefile.PE(data=buf[i:])
            except:
                continue
            print(f'  [*] Found PE file at offset 0x{i:X}')
            found.append({'offset': i, 'data': pe.trim(), 'ext': self.get_ext(pe) })
        return found

    def get_ext(self, pe):
        # https://github.com/MalwareLu/tools/blob/master/pe-carv.py
        'returns ext of the file type using pefile'
        if pe.is_dll() == True:
            return 'dll'
        if pe.is_driver() == True:
            return 'sys'
        if pe.is_exe() == True:
            return 'exe'
        else:
            return 'bin'

    def hookRtlAllocateHeap(self, emu, api_name, func, params):
        """
        Hook Allocate Heap and record memory addresses
        """
        # Address Start
        rv = func(params)
        # Len of Allocated Mem
        length = params[2]
        end = rv + length
        mem = {'Base': rv, 'Length': length, 'End': end}
        self.dump_addr.append(mem)
        print("[*] RtlAllocateHeap Called! Recording allocated memory.")
        return rv

    def hookNtClose(self, emu, api_name, func, params):
        print("[*] NtClose CALLED! Dumping memory from allocated regions.")
        self.stop()
        self.dump()

    def run(self):
        self.module = self.load_module(self.input_path)
        self.add_api_hook(self.hookRtlAllocateHeap, 'ntdll', 'RtlAllocateHeap')
        self.add_api_hook(self.hookNtClose, 'ntdll', 'NtClose')
        self.run_module(self.module, all_entrypoints=True)

def main(args):
    unpacker = SPLCryptUnpacker(args.file, args.outfile)
    unpacker.run()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='SPLCrypt Unpacker unpacker')
    parser.add_argument('-f', '--file', action='store', dest='file',
                        required=True, help='Path of file to unpack')
    parser.add_argument('-o', '--outfile', action='store', dest='outfile',
                        required=True, help='Path to save unpacked file')
    args = parser.parse_args()
    main(args)

