from binascii import hexlify, unhexlify
import pefile
import regex as re
import argparse
import logging
import traceback
import os
from arc4 import ARC4
import quicklz
from malduck import u32, p32, xor

def configure_logger(log_level):
    log_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'SPL_Unpack.log')
    log_levels = {0: logging.ERROR, 1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}
    log_level = min(max(log_level, 0), 3) #clamp to 0-3 inclusive
    logging.basicConfig(level=log_levels[log_level], 
                        format='%(asctime)s - %(name)s - %(levelname)-8s %(message)s',
                        handlers=[
                            logging.FileHandler(log_file, 'a'),
                            logging.StreamHandler()
                        ])

class UnpackerError(Exception):
    pass

class Unpacker:
    
    def __init__(self, input_file, output_file=None):
        self.logger = logging.getLogger('SPL Unpacker Logger')
        self.input_file = input_file
        self.output_file = output_file
        self.output = bytes()
        self.marker = b'|SPL|'
        self.key_regex = re.compile(rb'\xC7\x44\x24(?P<offset>.)(?P<key>[^\x00]{4})', re.DOTALL)
        #self.key_operation = re.compile(rb'(?P<rex>(\x81|\x83))(?P<operation>(\x44|\x6C))\x24(?P<offset>.)(?P<op_value>....)', re.DOTALL)
        self.key_operation = re.compile(rb'(?P<rex>(\x81|\x83))(?P<operation>(\x44|\x6C))\x24(?P<offset>.)(?P<op_value>[^\x00]{1})', re.DOTALL)
        self.ciphertext = re.compile(rb'(?P<ciphertext>[0-9a-fA-F]{1000,})', re.DOTALL)
        self.quicklz_compressed_regex = re.compile(rb'(?P<compressed_exe>.{6}\x4D\x5A\x90.*)', re.DOTALL)
        with open(self.input_file, 'rb') as fp:
            self.data = fp.read()
        self.pe = pefile.PE(self.input_file, fast_load=False)
        self.plaintext = None

    def rc4_decrypt(self, key, ciphertext):
        """
        RC4 Decrypt Ciphertext
        """
        try:
            arc4 = ARC4(key)
            return arc4.decrypt(ciphertext)
        except Exception as e:
            raise UnpackerError(f'Error RC4 decrypting ciphertext. {e}')    
    
    def xor_decrypt(self, key, ciphertext):
        """
        Xor Decrypt Ciphertext
        """
        dec = bytearray(ciphertext) 
        try:
            for x in range(len(ciphertext) - 1):
                dec[x] = ((dec[x] ^ key[x % len(key)]) - dec[x + 1]) & 0xff
            return dec
        except Exception as e:
            raise UnpackerError(f'Error XOR decrypting ciphertext. {e}')    

    def quicklz_decompress(self, ciphertext):
        """
        QuickLZ Decompress
        """
        try:
            plaintext = quicklz.decompress(ciphertext)
            for x in plaintext.split(self.marker):
                if x.startswith(b'\x4D\x5A'):
                    return x
        except Exception as e:
            self.logger.critical('Error decompressing ciphertext {e}')
            raise UnpackerError(f'{e}')     

    def unpack(self):
        """
        Extract key and config and decrypt
        """
        # Extract Key (Calculate key based on original ins + the add/sub op.
        self.logger.critical(f'[*] Searching for key...')
        key_match = self.key_regex.search(self.data)
        self.logger.debug(f'[*] Key Instruction found {hexlify(key_match.group())}')
        self.logger.debug(f'[*] Pre-op key is {hexlify(key_match.group("key"))}')
        
        key_op = self.key_operation.finditer(self.data)
        # Find correct key operation
        for x in key_op:
            self.logger.critical(f'Possible Key Operation: {hexlify(x.group())}')
            if x.group('offset') == key_match.group('offset'):
                key_op = x
                break
        self.logger.debug(f'[*] Key operation is {hexlify(key_op.group())}')
        if key_op:
            # Convert to int to do maths
            key_int = int.from_bytes(key_match.group('key'), 'little')
            op_int = int.from_bytes(key_op.group('op_value'), 'little')
            
            # Perform maths
            self.logger.critical(f'[*] Calculating RC4 key...') 
            if key_op.group('operation') == b'\x44':
                self.logger.debug(f'[*] Operation is add')
                key = (key_int + op_int).to_bytes(4, 'little')
            elif key_op.group('operation') == b'\x6C':
                self.logger.debug(f'[*] Operation is sub') 
                key = (key_int - op_int).to_bytes(4, 'little') 
            else:
                raise UnpackerError(f'Error calculating key')
        self.logger.critical(f'[*] Key is {hexlify(key)}')

        # Get blobs
        self.logger.critical(f'[*] Extracting ciphertext...')
        blobs = self.ciphertext.findall(self.data)
        blob1 = None
        blob2 = None
        if len(blobs) > 1:
            blob1 = blobs[0] + blobs[1] 
            blob2 = blobs[1] + blobs[0]
        else:
            blob1 = blobs[0] 
        
        # RC4 Decrypt Ciphertext
        self.logger.critical(f'[*] RC4 Decrypting ciphertext...')
        
        try:
            if b'\x7C\x53\x50\x4C\x7C' in self.rc4_decrypt(key, unhexlify(blob1)):
                decrypted = self.rc4_decrypt(key, unhexlify(blob1))
            elif blob2 and b'\x7C\x53\x50\x4C\x7C' in self.rc4_decrypt(key, unhexlify(blob2)):
                decrypted = self.rc4_decrypt(key, unhexlify(blob2))
            elif b'\x7C\x53\x50\x4C\x7C' in self.xor_decrypt(key, self.rc4_decrypt(key, unhexlify(blob1))):
                decrypted = self.xor_decrypt(key, self.rc4_decrypt(key, unhexlify(blob1)))
            elif blob2 and b'\x7C\x53\x50\x4C\x7C' in self.xor_decrypt(self.rc4_decrypt(key, unhexlify(blob2))):
                decrypted = self.xor_decrypt(key, self.rc4_decrypt(key, unhexlify(blob2)))
            else:
                raise UnpackerError(f'Could not successfully decrypt ciphertext with given key: {key}')
        except Exception as e:
            raise UnpackerError(f'Could not successfully decrypt ciphertext with given key: {key}')

        needs_decompressed = True
        for x in decrypted.split(self.marker):
            if x.startswith(b'\x4D\x5A') and b'\x70\x72\x6f\x67\x72\x61\x6d' in x:
                self.output = x
                needs_decompressed = False  
         
        # QuickLZ Decompress
        if needs_decompressed:
            self.logger.critical(f'[*] Decompressing ciphertext...')
            self.output = self.quicklz_decompress(bytes(decrypted)) 
            plaintext = quicklz.decompress(decrypted)
            for x in plaintext.split(self.marker):
                if x.startswith(b'\x4D\x5A'):
                    self.output = x    

    def write_output(self):
        """
        Write output to a given file
        """
        if self.output:
            self.logger.critical(f'[*] Writing unpacked payload to {self.output_file}')
            try:
                with open(self.output_file, 'wb') as fp:
                    fp.write(self.output)
            except Exception as e:
                self.logger.critical(traceback.format_exc())
        else:
            raise UnpackerError(f'Could not successfully unpack executable from file.')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='SPLCrypt Unpacker')
    parser.add_argument('-v', '--verbose', action='count', default=0, 
        help='Increase verbosity. Can specify multiple times for more verbose output')
    parser.add_argument('-f', '--file', action='store', dest='file',
                        required=True, help='Path of file to unpack') 
    parser.add_argument('-o', '--outfile', action='store', dest='outfile',
                       required=False, help='Path to write unpacked file')
    args = parser.parse_args()
    configure_logger(args.verbose)
    unpacker = Unpacker(args.file, args.outfile)
    try:
        unpacker.unpack()
        if args.outfile:
            unpacker.write_output()
    except Exception as e:
        print(f'Exception processing {args.file}:')
        print(traceback.format_exc())
    
