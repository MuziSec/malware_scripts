from binascii import hexlify, unhexlify
import pefile
import regex as re
import argparse
import logging
import traceback
import os
from arc4 import ARC4
import quicklz
from malduck import u32, p32, xor

def configure_logger(log_level):
    log_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'SPL_Unpack.log')
    log_levels = {0: logging.ERROR, 1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}
    log_level = min(max(log_level, 0), 3) #clamp to 0-3 inclusive
    logging.basicConfig(level=log_levels[log_level], 
                        format='%(asctime)s - %(name)s - %(levelname)-8s %(message)s',
                        handlers=[
                            logging.FileHandler(log_file, 'a'),
                            logging.StreamHandler()
                        ])

class UnpackerError(Exception):
    pass

class Unpacker:
    
    def __init__(self, input_file, output_file=None):
        self.logger = logging.getLogger('SPL Unpacker Logger')
        self.input_file = input_file
        self.output_file = output_file
        self.output = bytes()
        self.marker = b'|SPL|'
        self.is32bit = True
        self.possible_keys = []
        self.key_regex = re.compile(rb'\xC7\x44\x24(?P<offset>.)(?P<key>[^\x00].{3})', re.DOTALL)
        self.key_operation = re.compile(rb'(?P<rex>(\x81|\x83))(?P<operation>(\x44|\x6C))\x24(?P<offset>.)(?P<op_value>[^\x00]{1}.{3})', re.DOTALL)
        self.key_regex_32 = re.compile(rb'\xC7\x45(?P<offset>.)(?P<key>[^\x00].{3})', re.DOTALL)
        self.key_operation_32 = re.compile(rb'((?P<rex>(\x81|\x83))(?P<operation>(\x45|\x6D))(?P<offset>.)(?P<op_value>[^\x00]{1}.{3}))', re.DOTALL) 
        self.ciphertext = re.compile(rb'(?P<ciphertext>[0-9a-fA-F]{1000,})', re.DOTALL)
        with open(self.input_file, 'rb') as fp:
            self.data = fp.read()
        self.pe = pefile.PE(self.input_file, fast_load=False)
        self.plaintext = None

    def rc4_decrypt(self, key, ciphertext):
        """
        RC4 Decrypt Ciphertext
        """
        try:
            arc4 = ARC4(key)
            return arc4.decrypt(ciphertext)
        except Exception as e:
            self.logger.debug(f'Error RC4 decrypting ciphertext: {e}')    
            return None

    def xor_decrypt(self, key, ciphertext):
        """
        Xor Decrypt Ciphertext
        """
        dec = bytearray(ciphertext) 
        try:
            for x in range(len(ciphertext) - 1):
                dec[x] = ((dec[x] ^ key[x % len(key)]) - dec[x + 1]) & 0xff
            return dec
        except Exception as e:
            self.logger.debug(f'Error XOR decrypting ciphertext. {e}')    
            return None

    def quicklz_decompress(self, ciphertext):
        """
        QuickLZ Decompress
        """
        try:
            plaintext = quicklz.decompress(ciphertext)
            for x in plaintext.split(self.marker):
                if x.startswith(b'\x4D\x5A'):
                    return x
        except Exception as e:
            self.logger.critical('Error decompressing ciphertext {e}')
            return None

    def generate_possible_keys(self, key_matches, key_ops):
        for match in key_matches:
            self.logger.debug(f'Key match: {hexlify(match.group())}')
            for op in key_ops:
                self.logger.debug(f'Op: {hexlify(match.group())}')
                # Check offset to make sure it's a match 
                if match.group('offset') == op.group('offset'):
                    self.logger.debug(f'Op matching offset: {hexlify(op.group())}')
                    # Get length of op value
                    if op.group('rex') == b'\x81':
                        len_op_val = 4
                    elif op.group('rex') == b'\x83':
                        len_op_val = 1
                    else:
                        len_op_val = None
                    
                    if len_op_val:
                        # Convert to int to do maths
                        key_int = int.from_bytes(match.group('key'), 'little')
                        op_int = int.from_bytes(op.group('op_value')[:len_op_val], 'little')
                        key = None
                        # Check if add or sub and do math
                        try:
                            if self.is32bit and op.group('operation') == b'\x45':
                                key = (key_int + op_int).to_bytes(4, 'little')
                            elif self.is32bit and op.group('operation') == b'\x6D':
                                key = (key_int - op_int).to_bytes(4, 'little') 
                            elif not self.is32bit and op.group('operation') == b'\x44':
                                key = (key_int + op_int).to_bytes(4, 'little')
                            elif not self.is32bit and op.group('operation') == b'\x6C':
                                key = (key_int - op_int).to_bytes(4, 'little')
                        except Exception as e:
                            self.logger.debug('Could not do math on key.') 
                            pass
                        # Add key to potentials list
                        if key:
                            self.possible_keys.append(key)
                    
    def unpack(self):
        """
        Extract key and config and decrypt
        """
        # Check 32 or 64 bit
        if self.pe.FILE_HEADER.Machine == 0x014c:
            self.is32bit = True
        elif self.pe.FILE_HEADER.Machine == 0x8664:
            self.is32bit = False
        else:
            raise UnpackerError(f'File is not a PE file.')

        # Extract Key (Calculate key based on original ins + the add/sub op.
        self.logger.critical(f'[*] Searching for key...')
        
        # 32-bit SPLCrypt
        if self.is32bit:
            key_match = [match for match in self.key_regex_32.finditer(self.data)]
            key_ops = [match for match in self.key_operation_32.finditer(self.data)]
            
            # Find correct key operation
            self.generate_possible_keys(key_match, key_ops)
            
            
        # 64-bit SPLCrypt
        if not self.is32bit:
            key_match = [match for match in self.key_regex.finditer(self.data)]
            key_ops = [match for match in self.key_operation.finditer(self.data)]
            
            # Find correct key operation
            self.generate_possible_keys(key_match, key_ops)

        # Get blobs
        self.logger.critical(f'[*] Extracting ciphertext...')
        blobs = self.ciphertext.findall(self.data)
        blob1 = None
        blob2 = None
        if len(blobs) > 1:
            blob1 = blobs[0] + blobs[1] 
            blob2 = blobs[1] + blobs[0]
        else:
            blob1 = blobs[0] 

        print(self.possible_keys)        
        # RC4 Decrypt Ciphertext
        self.logger.critical(f'[*] RC4 Decrypting ciphertext...')
        
        for key in self.possible_keys:
            decrypted = None
            try:
                if b'\x7C\x53\x50\x4C\x7C' in self.rc4_decrypt(key, unhexlify(blob1)):
                    decrypted = self.rc4_decrypt(key, unhexlify(blob1))
                elif blob2 and b'\x7C\x53\x50\x4C\x7C' in self.rc4_decrypt(key, unhexlify(blob2)):
                    decrypted = self.rc4_decrypt(key, unhexlify(blob2))
                elif b'\x7C\x53\x50\x4C\x7C' in self.xor_decrypt(key, self.rc4_decrypt(key, unhexlify(blob1))):
                    decrypted = self.xor_decrypt(key, self.rc4_decrypt(key, unhexlify(blob1)))
                elif blob2 and b'\x7C\x53\x50\x4C\x7C' in self.xor_decrypt(key, self.rc4_decrypt(key, unhexlify(blob2))):
                    decrypted = self.xor_decrypt(key, self.rc4_decrypt(key, unhexlify(blob2)))
                else:
                    self.logger.debug(f'Could not decrypt ciphertext using key {hexlify(key)}')
            except Exception as e:
                self.logger.debug(f'Could not successfully decrypt ciphertext with given key: {key}')

            needs_decompressed = True
            if decrypted:
                for x in decrypted.split(self.marker):
                    if x.startswith(b'\x4D\x5A') and b'\x70\x72\x6f\x67\x72\x61\x6d' in x:
                        self.output = x
                        break
 
                # QuickLZ Decompress
                self.logger.critical(f'[*] Decompressing ciphertext...')
                plaintext = self.quicklz_decompress(bytes(decrypted))
                if plaintext:
                    for x in plaintext.split(self.marker):
                        if x.startswith(b'\x4D\x5A'):
                            self.output = x
                            break

    def write_output(self):
        """
        Write output to a given file
        """
        if self.output:
            self.logger.critical(f'[*] Writing unpacked payload to {self.output_file}')
            try:
                with open(self.output_file, 'wb') as fp:
                    fp.write(self.output)
            except Exception as e:
                self.logger.critical(traceback.format_exc())
        else:
            raise UnpackerError(f'Could not successfully unpack executable from file.')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='SPLCrypt Unpacker')
    parser.add_argument('-v', '--verbose', action='count', default=0, 
        help='Increase verbosity. Can specify multiple times for more verbose output')
    parser.add_argument('-f', '--file', action='store', dest='file',
                        required=True, help='Path of file to unpack') 
    parser.add_argument('-o', '--outfile', action='store', dest='outfile',
                       required=False, help='Path to write unpacked file')
    args = parser.parse_args()
    configure_logger(args.verbose)
    unpacker = Unpacker(args.file, args.outfile)
    try:
        unpacker.unpack()
        if args.outfile:
            unpacker.write_output()
    except Exception as e:
        print(f'Exception processing {args.file}:')
        print(traceback.format_exc())
    
