from arc4 import ARC4
from binascii import hexlify, unhexlify
import pefile
import re

def main():

    # Get Key and convert to bytes
    # key = "7E97016E"
    # key_bytes = bytes.fromhex(key)
    # print("Key Bytes: ")
    # print(key_bytes)

    # Parse our PE File
    pe = pefile.PE('splcrypt_64bit.bin')
    # pe.print_info()

    # Test Key Extraction
    key_regex = re.compile(br'\xC7\x44\x24[^\x00]{5}')
    key_operation = re.compile(br'\x83\x44\x24[^\x00]{2,5}\x48')

    # Search exe for key and key operation
    print("Searching exe for key and key operation.")
    with open('splcrypt_64bit.bin', 'rb') as fp:
        data = fp.read()
    print("Preop Key found: ")
    print(hexlify(key_regex.findall(data)[0][4:]))
    preop_key = hexlify(key_regex.findall(data)[0][4:])
    print("Key operation found: ")
    # print(hexlify(key_operation.findall(data)[0][4:]))
    operation = hexlify(key_operation.findall(data)[0][0:-1])
    print(operation)

    # Determine operation (83 == add, 81 == sub)
    print("Parsing operation :")
    if operation[:2] == b'83':
        op = "add"
        print(f"Key operation is: {op}")
    elif operation[:2] == b'81':
        op = "sub"
        print(f"Key operation is: {op}")
    else:
        print("IDK")

    # Calculate final RC4 key based on operation
    print("Calculating RC4 key: ")
    value = operation[8:]
    if len(value) != 8:
        zeros = ((8 - len(value)) * b'0').decode('utf-8')
        # Decode to append zeros to string
        final_value = value.decode('utf-8') + zeros
        # Encode to bytes again for math
        final_value = final_value.encode('utf-8')

    # Perform math on preop key
    if op == "add":
        key = hex(int(preop_key,16) + int(final_value, 16))
        key = unhexlify(key[2:].encode('utf-8'))
        print(f"RC4 key is {key}")
    elif op == "sub":
        key = hex(int(preop_key,16) - int(final_value, 16))
        key = unhexlify(key[2:].encode('utf-8'))
        print(f"RC4 key is {key}")

    # Search sections for sections with encrypted data
    ctba = bytearray()
    for section in pe.sections:
        if b"data" in section.Name and b"." not in section.Name:
             ciphertext = unhexlify(section.get_data().rstrip(b'\x00'))
             # Decrypt must check each section since there's always two potential sections
             arc4 = ARC4(key)
             compressed = arc4.decrypt(ciphertext)
             if b"\x4d\x5a" in compressed and b"\x70\x72\x6f\x67\x72\x61\x6d" in compressed:
                 print(section.Name)
                 first = ciphertext
             else:
                 second = ciphertext
    
    print(len(first))
    print(len(second))
    ctba += first
    ctba += second
    ct = bytes(ctba)    
    print(len(ct))

    arc4 = ARC4(key)
    final_compressed = arc4.decrypt(ct) 
    print(hexlify(final_compressed[:10]))
    """
    # RC4 Decrypt
    print(f"Decrypting using key: {key}")
    arc4 = ARC4(key)
    compressed = arc4.decrypt(ciphertext)
    """
    """
    print("Head of output: ")
    print(hexlify(compressed[:10]))
    print(compressed[:10])
    """

    # Write Compressed to File
    with open("compressed.out", "wb") as fp:
        fp.write(final_compressed)

    # Decompress

if __name__ == '__main__':
    main()

