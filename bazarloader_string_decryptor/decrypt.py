from binascii import hexlify, unhexlify
import pefile
import re
import yara
import string
import argparse

class Decryptor:
    
    def __init__(self, input_file, output_file=None):
        self.input_file = input_file
        self.output_file = output_file
        self.yara_path = './yara/BazarLoader.yar'
        self.mov_regex = re.compile(br'c7(4.{1})([^\x8b]|[^\xc7]|[^\x89]){12}')
        self.hash_keys = []
        self.reg_keys = []
        self.output_strings = []

    def extract_strings(self):
        # Extract string decryption instructions
        rule = yara.compile(filepath=self.yara_path)
        matches = rule.match(self.input_file)

        for match in matches:
            # Extract C7/Mov Hashes
            for x in match.strings:
                if x[1] == "$xor_hash":
                    ciphertext = bytearray()
                    key = bytearray(x[2][-4:])
                    if key not in self.hash_keys:
                        #print(f"Match: {hexlify(x[2])}")
                        #print(f"Key: {hexlify(key)}")
                        #print(f"Key: {key}")
                        self.hash_keys.append(key)
                        for y in self.mov_regex.finditer(hexlify(x[2])):
                            s = y.start()
                            e = y.end()
                            #print(f"Bytes: {hexlify(x[2])[s:e][-8:]}")
                            z = hexlify(x[2])[s:e][-8:] 
                            #print(f"ZBytes: {z}")
                            ciphertext += unhexlify(z)
                        #print(f"Ciphertext: {hexlify(ciphertext)}")
                        try:
                            decoded = self.str_xor(ciphertext, key).decode()
                            filtered = ''.join(filter(lambda x: x in string.printable, decoded))
                            print(filtered)
                            self.output_strings.append(filtered)                
                        except Exception as e:
                            continue
                elif x[1] == "$xor_reg":
                    ciphertext = bytearray()
                    key = bytearray(x[2][1:5])
                    print(f"Key: {hexlify(key)}")
                    if key not in self.reg_keys:
                        self.reg_keys.append(key)
                        for y in self.mov_regex.finditer(hexlify(x[2])):
                            s = y.start()
                            e = y.end()
                            z = hexlify(x[2])[s:e][-8:] 
                            ciphertext += unhexlify(z)
                            print(f"Ciphertext: {hexlify(ciphertext)}")
                        try:
                            decoded = self.str_xor(ciphertext, key).decode()
                            filtered = ''.join(filter(lambda x: x in string.printable, decoded))
                            print(filtered)
                            self.output_strings.append(filtered)
                        except Exception as e:
                            continue

    def str_xor(self, data, key):
        for i in range(len(data)):
            data[i] ^= key[i % len(key)]
        return data

    def write_output(self):
        with open(self.output_file, 'w') as fp:
            for x in self.output_strings:    
                fp.write(x)
                fp.write('\n')

def main(args):
    decryptor = Decryptor(args.file, args.outfile)
    decryptor.extract_strings()
    if args.outfile:
        decryptor.write_output()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='BazarLoader String Decryptor')
    parser.add_argument('-f', '--file', action='store', dest='file',
                        required=True, help='Path of file to unpack')
    parser.add_argument('-o', '--outfile', action='store', dest='outfile',
                        required=False, help='Path to write unpacked strings')
    args = parser.parse_args()
    main(args)
