from binascii import hexlify, unhexlify
import pefile
import regex as re
import yara
import string
import argparse
import logging
import traceback
import os

def configure_logger(log_level):
    log_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'unpacker.log')
    log_levels = {0: logging.ERROR, 1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}
    log_level = min(max(log_level, 0), 3) #clamp to 0-3 inclusive
    logging.basicConfig(level=log_levels[log_level], 
                        format='%(asctime)s - %(name)s - %(levelname)-8s %(message)s',
                        handlers=[
                            logging.FileHandler(log_file, 'a'),
                            logging.StreamHandler()
                        ])

class Decryptor:
    
    def __init__(self, input_file, output_file=None):
        self.logger = logging.getLogger('BazarLoader String Decryptor Logger')
        self.input_file = input_file
        self.output_file = output_file
        self.yara_path = './yara/BazarLoader.yar'
        self.mov_regex = re.compile(rb'(\xC7(\x44\x24|\x45)(?P<offset>.)(?P<str>....).{,3}?){5,}', re.DOTALL)
        self.hash_keys = []
        self.reg_keys = []
        self.output_strings = []

    def extract_strings(self):
        """
        Extract ciphertext (hashes) and keys and perform decryption of strings in BazarLoader
        """
        rule = yara.compile(filepath=self.yara_path)
        matches = rule.match(self.input_file)
        asdf = True
        for match in matches:
            # Extract C7/Mov Hashes
            for x in match.strings:
                if x[1] == "$xor_hash":
                    ciphertext = bytearray()
                    key = bytearray(x[2][-4:])
                    #print(f'Key: {hexlify(key)}')
                    self.logger.debug(f'Key found for hash xor method: {hexlify(key)}')
                    self.logger.debug(f'match: {hexlify(x[2])}')
                    #print(hexlify(x[2]))
                    if key not in self.hash_keys:
                        self.hash_keys.append(key)
                        self.logger.info(f'Added key {hexlify(key)} to key array to prevent reuse')
                        for y in self.mov_regex.finditer(x[2]):
                            z = b''
                            d = {int.from_bytes(y.captures('offset')[i], byteorder='little'): y.captures('str')[i] for i in range(len(y.captures('str')))}
                            self.logger.debug(f'{d}')
                            for k,v in d.items():
                                z += hexlify(v)
                            #z = hexlify(x[2])[s:e][-8:] 
                            #print(f"ZBytes: {z}")
                            ciphertext += unhexlify(z)
                        #print(f"Ciphertext: {hexlify(ciphertext)}")
                        try:
                            self.logger.info(f'Decrypting ciphertext: {hexlify(ciphertext)} with key: {hexlify(key)}')
                            decoded = self.str_xor(ciphertext, key).decode()
                            filtered = ''.join(filter(lambda x: x in string.printable, decoded))
                            if filtered:
                                print(filtered)
                            self.output_strings.append(filtered)               
                            self.logger.debug(f'String decrypted: {filtered}') 
                        except Exception as e:
                            self.logger.debug(traceback.format_exc())
                            continue
                elif x[1] == "$xor_reg":
                    ciphertext = bytearray()
                    key = bytearray(x[2][1:5])
                    self.logger.debug(f'Key found for hash xor method: {hexlify(key)}')
                    self.logger.debug(f'match: {hexlify(x[2])}')
                    if key not in self.reg_keys:
                        self.reg_keys.append(key)
                        self.logger.info(f'Added key {hexlify(key)} to key array to prevent reuse')
                        for y in self.mov_regex.finditer(x[2]):
                            z = b''
                            d = {int.from_bytes(y.captures('offset')[i], byteorder='little'): y.captures('str')[i] for i in range(len(y.captures('str')))}
                            for k,v in d.items():
                                z += hexlify(v)
                            ciphertext += unhexlify(z)
                        try:
                            self.logger.info(f'Decrypting ciphertext: {hexlify(ciphertext)} with key: {hexlify(key)}')
                            decoded = self.str_xor(ciphertext, key).decode()
                            filtered = ''.join(filter(lambda x: x in string.printable, decoded))
                            if filtered:
                                print(filtered)
                            self.output_strings.append(filtered)
                            self.logger.debug(f'String decrypted: {filtered}')
                        except Exception as e:
                            self.logger.debug(traceback.format_exc())
                            continue

    def str_xor(self, data, key):
        """
        XOR Ciphertext by Key
        """
        for i in range(len(data)):
            data[i] ^= key[i % len(key)]
        return data

    def write_output(self):
        """
        Write output to a given file
        """
        try:
            with open(self.output_file, 'w') as fp:
                for x in self.output_strings:    
                    fp.write(x)
                    fp.write('\n')
        except Exception as e:
            self.logger.critical(traceback.format_exc())

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='BazarLoader String Decryptor')
    parser.add_argument('-f', '--file', action='store', dest='file',
                        required=True, help='Path of file to unpack')
    parser.add_argument('-o', '--outfile', action='store', dest='outfile',
                        required=False, help='Path to write unpacked strings')
    parser.add_argument('-v', '--verbose', action='count', default=0, 
        help='Increase verbosity. Can specify multiple times for more verbose output')
    args = parser.parse_args()
    configure_logger(args.verbose)
    decryptor = Decryptor(args.file, args.outfile)
    try:
        decryptor.extract_strings()
        if args.outfile:
            decryptor.write_output()
    except Exception as e:
        print(f'Exception processing {args.file}:')
        print(traceback.format_exc())
    
