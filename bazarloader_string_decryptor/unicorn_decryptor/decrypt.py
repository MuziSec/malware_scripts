import sys
import regex as re
from binascii import hexlify, unhexlify
import struct
import yara
from unicorn import *
from unicorn.x86_const import *
import string

# Regex Instruction Extraction
data = open(sys.argv[1], 'rb').read()
mov_regex = re.compile(rb'(\xC7(\x44\x24|\x45)(?P<offset>.)(?P<str>....).{,8}){1,}.{,100}\x72\xEA', re.DOTALL)
xor_reg_regex = re.compile(rb'(\xBA.{,8}\xC7(\x44\x24|\x45)(?P<offset>.)(?P<str>....).{,8}){1,}.{,100}\x72\xED', re.DOTALL)

instructions = []
for x in mov_regex.finditer(data):
    ins = hexlify(x.group())
    instructions.append(unhexlify(ins))

for y in xor_reg_regex.finditer(data):
    ins = hexlify(y.group())
    instructions.append(unhexlify(ins))

for ins in instructions:
    # Set up Unicorn
    ADDRESS = 0x10000000
    STACK_ADDRESS = 0x90000
    mu = Uc(UC_ARCH_X86, UC_MODE_64)
    mu.mem_map(ADDRESS, 4 * 1024 * 1024)
    mu.mem_map(STACK_ADDRESS, 4096*10)
    mu.mem_write(ADDRESS, b'\x00'*0x100000)
    mu.mem_write(STACK_ADDRESS, b'\x00'*(4096*10))

    # Write code to memory
    mu.mem_write(ADDRESS, ins)
    # Initialize Stack for functions
    mu.reg_write(UC_X86_REG_RSP, STACK_ADDRESS + 4096)
    mu.reg_write(UC_X86_REG_RBP, STACK_ADDRESS + 4096)
    mu.reg_write(UC_X86_REG_R8, 0x00)
    mu.reg_write(UC_X86_REG_R9, 0x00)
    mu.reg_write(UC_X86_REG_RDI, 0x00)
    mu.reg_write(UC_X86_REG_RDX, 0x01) 
    mu.reg_write(UC_X86_REG_RSI, 0x01)
    mu.reg_write(UC_X86_REG_R10, 0x00)
    mu.reg_write(UC_X86_REG_R11, 0x00)
    mu.reg_write(UC_X86_REG_R12, 0x01)
    mu.reg_write(UC_X86_REG_R13, 0x00)
    mu.reg_write(UC_X86_REG_R14, 0x00)
    mu.reg_write(UC_X86_REG_R15, 0x01)
    mu.reg_write(UC_X86_REG_RBX, 0x00)

    # Run the code
    try:
        mu.emu_start(ADDRESS, ADDRESS + len(ins), timeout=10000)
    except UcError as e:
        print(hexlify(ins))
        print(e)

    b = mu.mem_read(STACK_ADDRESS, 4096*10)
    #print(b)

    with open('output.txt', 'ab') as fp:
        fp.write(b)
