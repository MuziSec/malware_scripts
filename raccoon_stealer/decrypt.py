from binascii import hexlify, unhexlify
import pefile
import regex as re
import argparse
import logging
import traceback
import os
import base64

def configure_logger(log_level):
    log_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'raccoon_stealer.log')
    log_levels = {0: logging.ERROR, 1: logging.WARNING, 2: logging.INFO, 3: logging.DEBUG}
    log_level = min(max(log_level, 0), 3) #clamp to 0-3 inclusive
    logging.basicConfig(level=log_levels[log_level], 
                        format='%(asctime)s - %(name)s - %(levelname)-8s %(message)s',
                        handlers=[
                            logging.FileHandler(log_file, 'a'),
                            logging.StreamHandler()
                        ])

class Decryptor:
    
    def __init__(self, input_file, output_file=None):
        self.logger = logging.getLogger('Raccoon Stealer String Decryptor Logger')
        self.input_file = input_file
        self.output_file = output_file
        self.config_key_regex = re.compile(rb'(\xBE(?P<key>....)\x8B.\xE8.{4}\x89\x45.{1}\xB9)', re.DOTALL)
        self.config_regex = re.compile(rb'\xB9(?P<ciphertext>....)\x8D.\xFC\x56\x50\xE8', re.DOTALL)
        self.key_regex = re.compile(rb'(\xBF(?P<key>....)\x8D.\xFC\x57\x51\xBE.{4}\x50\x8B.\xE8)', re.DOTALL)
        self.ct_regex = re.compile(rb'\xA3.{4}\xB9(?P<ciphertext>....)\xE8', re.DOTALL)
        self.config = []
        self.output_strings = []
        with open(self.input_file, 'rb') as fp:
            self.data = fp.read()

    def dereference_key_ptr(self, key_ptr):
        """
        Dereference key ptr and return key
        """
        key_ptr = int.from_bytes(key_ptr, "big")
        # PE File
        pe = pefile.PE(self.input_file, fast_load=False)
        # Extract Ciphertext Addr
        try:
            key_ptr = pe.get_offset_from_rva(key_ptr - pe.OPTIONAL_HEADER.ImageBase)
            self.logger.debug(f'Found key ptr at {hex(key_ptr)}')  
        except Exception as e:
            self.logger.debug(f'Key could not be found.')
            self.logger.critical(traceback.format_exc())
            raise
        
        # Extract key from ptr
        try:
            with open(self.input_file, 'rb') as fp:
                fp.seek(key_ptr, 0)
                key = fp.read(40)
                key = key.split(b'\x00')[0]
                self.logger.debug(f'Found key: {hexlify(key)}')
        except Exception as e:
            self.logger.debug(f"Couldn't read key from file.")
            self.logger.critical(traceback.format_exc())
        return key

    def dereference_ct_ptr(self, ciphertext_ptr):
        """
        Dereference ciphertext ptr and return ciphertext
        """
        ciphertext_ptr = int.from_bytes(ciphertext_ptr, "big")

        # PE File
        pe = pefile.PE(self.input_file, fast_load=False)
        try:
            # Extract Ciphertext Addr
            ct_ptr = pe.get_offset_from_rva(ciphertext_ptr - pe.OPTIONAL_HEADER.ImageBase)
            self.logger.debug(f'Found potential ciphertext ptr at {hex(ct_ptr)}')  
        except:
            self.logger.critical(f'CT Address Invalid PTR at {hex(ct_ptr)}')
            return

        # Extract ciphertext from ptr
        try:
            with open(self.input_file, 'rb') as fp:
                fp.seek(ct_ptr, 0)
                ciphertext = fp.read(200)
                ciphertext = ciphertext.split(b'\x00')[0]
                self.logger.debug(f'Found ciphertext: {hexlify(ciphertext)}')
        except Exception as e:
            self.logger.debug('Could not find ciphertext for {ct_ptr}')
            return

        return ciphertext

    def decryptb64(self, key, ciphertext):
        """
        Base64 decode and RC4 Decrypt. Return decrypted string.
        """
        try:
            unb64_ct = base64.b64decode(ciphertext.decode('ascii'))
            if type(unb64_ct) == str:
                unb64_ct = unb64_ct.encode('utf-8')
            if type(key) == str:
                key = key.encode('utf-8')
            x = 0
            box = list(range(256))
            for i in range(256):
                x = (x + box[i] + key[i % len(key)]) % 256
                box[i], box[x] = box[x], box[i]
            x = 0
            y = 0
            out = []
            for c in unb64_ct:
                x = (x + 1) % 256
                y = (y + box[x]) % 256
                box[x], box[y] = box[y], box[x]
                out.append(c ^ box[(box[x] + box[y]) % 256])
            #print(f'{bytes(out).decode("ascii")}')
            return bytes(out) 
        except:
            self.logger.debug(f'Could not decrypt provided ciphertext: {ciphertext}')

    def extract_strings(self):
        """
        Extract key and ciphertext and perform decryption of strings in Raccoon Stealer V2
        """
        # First extract the config
        key_match = self.config_key_regex.search(self.data).group('key')
        if not key_match:
            self.logger.warning(f'No config key found.')
        key_ptr = bytes(reversed(key_match))
        key = self.dereference_key_ptr(key_ptr)  
        matches = list(self.config_regex.finditer(self.data))
        for match in matches:
            if not match.group('ciphertext'):
                self.logger.warning(f'No ciphertext: {match.groupdict()}')
                continue
            ciphertext_ptr = bytes(reversed(match.group('ciphertext')))
            ciphertext = self.dereference_ct_ptr(ciphertext_ptr)    
            if ciphertext:
               decrypted = self.decryptb64(key, ciphertext)
               if decrypted:
                   try:
                       self.config.append(decrypted.decode('ascii'))
                   except:
                       self.logger.debug(f'Could not decode decrypted string: {decrypted}')
        print(f'Raccoon Stealer Config:')
        for x in self.config:
            if x.isprintable():
                print(x)

        # Now extract the strings 
        key_match = self.key_regex.search(self.data).group('key')
        if not key_match:
            self.logger.warning(f'No config key found.')
        key_ptr = bytes(reversed(key_match))
        key = self.dereference_key_ptr(key_ptr)  
        matches = list(self.ct_regex.finditer(self.data))
        for match in matches:
            if not match.group('ciphertext'):
                self.logger.warning(f'No ciphertext: {match.groupdict()}')
                continue
            ciphertext_ptr = bytes(reversed(match.group('ciphertext')))
            ciphertext = self.dereference_ct_ptr(ciphertext_ptr)    
            if ciphertext:
               decrypted = self.decryptb64(key, ciphertext)
               if decrypted:
                   try:
                       self.output_strings.append(decrypted.decode('ascii'))
                   except:
                       self.logger.debug(f'Could not decode decrypted string: {decrypted}')
        # Print Decrypted Strings
        print(f'Raccoon Stealer Decrypted Strings:')
        for x in self.output_strings:
            print(x)

    def write_output(self):
        """
        Write output to a given file
        """
        try:
            with open(self.output_file, 'w') as fp:
                fp.write('Raccoon Stealer Config: \n') 
                for x in self.config:
                    fp.write(str(x))
                fp.write('\n') 
                fp.write('Raccoon Stealer Decrypted Strings: \n')
                for x in self.output_strings:
                    fp.write(str(x))
                    fp.write('\n')
        except Exception as e:
            self.logger.critical(traceback.format_exc())
            

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Raccoon Stealer String Decryptor')
    parser.add_argument('-f', '--file', action='store', dest='file',
                        required=True, help='Path of file to decrypt strings')
    parser.add_argument('-o', '--outfile', action='store', dest='outfile',
                        required=False, help='Path to write unpacked strings')
    parser.add_argument('-v', '--verbose', action='count', default=0, 
        help='Increase verbosity. Can specify multiple times for more verbose output')
    args = parser.parse_args()
    configure_logger(args.verbose)
    for file in args.files:
        decryptor = Decryptor(args.file, args.outfile)
        try:
            decryptor.extract_strings()
            if args.outfile:
                decryptor.write_output()
        except Exception as e:
            self.logger.error(f'Exception processing {args.file}:')
            print(traceback.format_exc())
    
