# Decrypt Raccoon Stealer Strings
#@muzi
#@category _String Decrypters_
#@keybinding 
#@menupath 
#@toolbar 

# Decrypt Raccoon Stealer Strings
# @muzisec www.github.com/muzisec
import base64

# These addresses need to be set on a per sample basis
dec_routine = toAddr(0x00401806)

# Decryption Keys - Must be manually set
config_key = "59c9737264c0b3209d9193b8ded6c"
str_key = "edinayarossiya"

listing = currentProgram.getListing()

# Decryption Function
def rc4_crypt(key, data):
    """Return the decrypted string."""
    S = list(range(256))
    j = 0

    for i in list(range(256)):
        j = (j + S[i] + ord(key[i % len(key)])) % 256
        S[i], S[j] = S[j], S[i]

    j = 0
    y = 0
    out = []
    
    for byte in data:
        j = (j + 1) % 256
        y = (y + S[j]) % 256
        S[j], S[y] = S[y], S[j]
        out.append(chr(byte ^ S[(S[j] + S[y]) % 256]))
    return ''.join(out)


# Loop through xrefs, get value in reg and decrypt
xrefs = getReferencesTo(dec_routine)

for xref in xrefs:
    callee = xref.getFromAddress()
    inst = getInstructionAt(callee)
    prev_inst = getInstructionBefore(inst)
    comm = prev_inst.getAddress()
    mnemonic = prev_inst.getMnemonicString()

    if mnemonic == "MOV":
       try:
           addrOfData = prev_inst.getOpObjects(1)[0]
           value = addrOfData.toString()
           if value != "EAX":
               dataAddress = parseAddress(value)
               dataBlock = getDataAt(dataAddress)
               datConstant = dataBlock.getValue()
               ciphertext = datConstant
               ciphertext = bytearray(base64.b64decode(ciphertext))
               plaintext = rc4_crypt(str_key, ciphertext)
               codeUnit = listing.getCodeUnitAt(comm)
               codeUnit.setComment(codeUnit.EOL_COMMENT,plaintext)
           
       except Exception as e:
           print(e)
           continue      



